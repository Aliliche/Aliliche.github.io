[ { "title": "FAQ langage C", "url": "/posts/FAQ-langage_C/", "categories": "Linux, C", "tags": "FAQ C", "date": "2022-10-22 17:05:00 +0200", "snippet": "" }, { "title": "Driver Linux pour Nokia 5110 LCD (PARTIE 2)", "url": "/posts/driver-nokia5110lcd-part2/", "categories": "Linux, Drivers", "tags": "drivers linux, lcd driver, nokia5010", "date": "2022-07-15 01:57:00 +0200", "snippet": "Coss-compilationLes systèmes Linux embarqués sont assez légers, généralement ils n’embarquent pas de compilateur gcc à l’intérieur, ce qui signifie que les compilations doivent êtres croisées. Sur Openwrt notamment, il n y a pas GDB ni GCC.Il existe plusieurs façons de cross compiler, le plus simple serait d’intégrer directement notre module dans le système et le compiler avec. C’est d’ailleurs ce que je vais faire à la fin, créer un module buildroot.Pour la phase de développement, j’ai choisi de cross-compiler avec les headers du Kernel. Les headers du Kernel sont un ensemble de fichiers d’entête écrits en C requis pour compiler n’importe quel code pour le Kernel. En gros c’est une définition des fonctions et des structures qu’on trouve trouve dans le kernel source tree, les plus importantsheaders sont dans include/linux et include/asm mais d’autres aussi sont ailleurs.Pour compiler notre driver, on doit générer ces headers à partir des sources Kernel de Openwrt qui tourne sur notre RPi4, ensuite on cross-compile sur la target avec la bonne toolchain. J’ai fait cette manipe car c’est plus simple que de compiler tout le Kernel.Ce fichier dessous sert à générer ces Kernel headers:#!/bin/bash# Ajouter au PATH le repo de la toolchain qui a compilé openwrt export PATH=$PATH:~/openwrt/staging_dir/toolchain-aarch64_cortex-a72_gcc-11.3.0_musl/bin/# Prefix pour la CROSS_COMPILATION Prefix=aarch64-openwrt-linux # Dossier qui va contenir nos KernelHeaders- KernelHeader=$PWD/KernelHeaders/# Compile à partir du dossier kernel de Openwrt cd ~/openwrt/build_dir/target-aarch64_cortex-a72_musl/linux-bcm27xx_bcm2711/linux-5.15.53 make ARCH=arm64 CROSS_COMPILE=$Prefix O=$KernelHeader mrproper;# Default kernel config for the board make ARCH=arm64 CROSS_COMPILE=$Prefix O=$KernelHeader defconfig;# Preparer les prérequis necessaires pour compiler un out-of-tree module make -j 8 ARCH=arm64 CROSS_COMPILE=$Prefix O=$KernelHeader modules_prepare; Le clean se fait sur trois niveaux.Make clean : supprimer la plupart des fichiers générés sauf la config et ceux utiles pour contruire des modulesmake mrproper : supprimer la configuration actuelle et tous les fichiers générésmake distclean: supprime les fichiers de sauvegarde de l’éditeur, les fichies de patchs , etc.On a maintenant les headers du Kernel, avec ceux ci on doit pouvoir cross-compiler.Pour ça il nous faut le petit module kernel :#include &amp;lt;linux/init.h&amp;gt;#include &amp;lt;linux/module.h&amp;gt;#include &amp;lt;linux/kernel.h&amp;gt;MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;Monkey&quot;);MODULE_DESCRIPTION(&quot;A simple Linux Kernel Module&quot;);MODULE_VERSION(&quot;0.1&quot;);static int __init hello_init(void){ printk(KERN_ALERT &quot;Hello all\\n&quot;); return 0;}static void __exit hello_exit(void){ printk(KERN_ALERT &quot;Goodbye all\\n&quot;);}module_init(hello_init);module_exit(hello_exit);Modules KernelIl y a quelques différences entre la programmation au niveau Kernel et en niveau User Space. Un module ou un driver suit les conventions de codage au niveau Kernel.Le module définit deux fonctions : hello_init() invoquée au chargement et hello_exit() invoquée au déchargement du module. Ces fonctions servent à enregistrer le driver au Kernel pour de futurs appelles . La fonction exit() doit défaire tout ce que la fonction init() a fait, par exemple désallouer de la mémoire.module_init() et module exit() utilisent des macros pour indiquer le rôle de chacune des fonctions “hello” cités précédemment.MODULE_LICENCE pour la licence, sans elle le Kernel va crier et Richard STALLMAN aussi d’ailleur.printk() se comporte comme printf() de la GNU C library. le Kernel tourne de lui même et ne nécessite pas des librairies C.Un programme peut appeler une fonction qu’il n’a pas définit, la phase de linkage résout ça en utilisant des librairies C, un module par contre n’est linké qu’au Kernel, donc les seuls fonctions qu’il peut appeler sont celles exportés par ce dérnier. Exemple: printk est définit auKernel et exporté aux modules. KERNEL_ALERT définit la priorité du message (info, alterte , erreur ,debug..etc).Le Makefile de compilation:# if KERNELRELEASE is defined, we&#39;ve been invoked from kernel build system# and can use its langageifneq ($(KERNELRELEASE),) obj-m := test.o# otherwise we were called directly from the command line; invok kbuild systemelse #safe asignement KERNELDIR ?=&quot;./KernelHeaders&quot; #call out the shell to execute command pwd PWD := $(shell pwd).PHONY: modulesmodules: $(MAKE) -C $(KERNELDIR) M=$(PWD) modulesendif.PHONY: cleanclean: $(MAKE) -C $(KERNELDIR) M=$(PWD) cleanCFLAGS_test.o := -DDEBUGExplication du makefileNormalement pour compiler un module, une simple ligne de code obj-m := module.o suffit, le responsable kbuild system fera le reste.Ce makefile est lu en deux fois:Quand le makefile est invoqué par une ligne de commande: cela signifie que la variable KERNELRELEASE est pas définit,dans ce cas kbuild system va se charger de trouver le Kernel source tree.Quand c’est invoqué par Kbuild system:Si le kernel pour lequel on compile n’est pas celui de la machine actuelle (eg. notre cas de cross compilation) alors il faut définir ou se trouve le Kernel source tree,une fois trouvé, le makefile appelle la target default et sa commande va compiler nos modules à partir des fichier objets spécifiés dans obj-m, c’est la seconde lecture (invocation par ligne de commande).Dans cette ligne, on change de directory pour aller dans le source tree du kernel pointé avec -C la où se trouvele top-level makefile du kernel. La seconde M=PWD fait déplacer ce top-level makefile sur le dossier courant ou sont nos source pour enfin compiler les fichiers objets specifiés par obj-m et générer des fichiers .koVoici un code qui apelle le Makefile avec les bons paramétres de cross-compilation:#!/bin/bashexport PATH=$PATH:/home/vicious/openwrt/staging_dir/toolchain-aarch64_cortex-a72_gcc-11.3.0_musl/bin/# Build the module make ARCH=arm64 CROSS_COMPILE=aarch64-openwrt-linux-# Informations about it modinfo test.ko Pour plus d’informations voir le chapitre II de Linux Device Drivers 3rd edition.Pour le makefile, un excellent Tuto de développez.comJ’envois le module par ssh sur mon RaspberryPi et je charge le module et HOP!! la cross-compialtion a fonctionné.dmesgPour décharger le module, il faut compiler OpenWRT avec l’option module unload.Les choses sérieuses commencent ici, il faut discuter d’une chose, le type de notre driver.Type du driverOn peut faire le driver de plusieurs façons, on peut le faire comme un driver de type char driver, c’est a dire que notre driver aura une interface de type char dans sysFs, on interagit avec le driver via un nœud dans /dev et on va initialiser et enregistrer notre LCD grâce à des fonctions init() et exit() au chargement du module. Le driver dans ce cas va utiliser directement les GPIO pour envoyer les donnés au LCD, c’est pas intéressant.Une autre façon serait d’utiliser le Bus SPI et donc l’API SPI du kernel. On va toujours interagir avec le LCD via /dev mais sans utiliser les fonctions de l’interface char (file_operations).En faisant des recherches sur le type d’API, helpers qu’il faut utiliser, je suis tombé sur une API très intéressants: Direct Randering Manager .J’ai trouvé ces helpers DRM car j’ai consulté le driver d’un autre écran LCD TFT que j’ai dans mon stock.Par contre, j’en ai trouvé deux types, les helpers DRM et les tiny-drm. Les tiny-drm se veulent plus faciles.Perdu , j’ai donc envoyé un message à un des mainteneurs du kernel Andy Shevchenko, il m’a répondu et a transféré mon message pour le mainteneur de la partie DRM du kernel.Voici sa réponse très intéressante.DRM vs Tiny-drmDonc décidé, je vais utiliser les helpers DRM.D’ailleurs c’est ce qu’on va faire !Device TreeUn device tree est un arbre de structures de données avec des nœuds décrivants le composant matériel.Selon ePAPR (power.org)Le device tree compilé porte une extension .dtb device tree blob Le fichier avant compilation est un .dts device tree source.pour le compiler on utilise le compilateur dtc :# installation dtcsudo apt-get install device-tree-compiler# Compialtion dts ou dtsidtc -I dts -O dtb -o devicetree_file_name.dtb devicetree_file_name.dts# conversion dts-&amp;gt;dtbdtc -I dts -O dtb -f devicetree_file_name.dts -o devicetree_file_name.dtb# conversion dtb-&amp;gt;dts dtc -I dtb -O dts -f devicetree_file_name.dtb -o devicetree_file_name.dtsles dtb et dts se trouvent dans le dossier ou sont décompressés et compilés les packages : /build_dir .bcm2711-rpi-4-b.dtb se trouve la ou il y a l’image linux et bcm2711-rpi-4-b.dts est dans build_dir/target-aarch64_cortex-a72_musl/linux-bcm27xx_bcm2711/linux-5.15.53/arch/arm/boot/dtsle device tree se compose de cette forme :Device tree. Source: Bootlin, Embedded Linux training by Thommas PetazzoniIl ya des nœuds qui représentent le device, chaque node est suivis de son adresse dans la mémoire.Le node a des propriétés, des sous node qu’on apelle child nodes et on voit qu’un node peut faire référence à un autre node, on apelle ça un phandle.Le node peut aussi avoir un label.Pour intégrer le device tree du LCD dans celui du kernel, un certains nombre de propriétés doit exister.tout d’abord, il faut que le node décrivant le LCD doit un un “child node” du contrôleur spi, donc toutes les propriétés ce ce controleurs doivent être spécifiés.voici la section qu’il faut ajouter en dessous du device spi numero 2:&amp;amp;spi0 { pinctrl-names = &quot;default&quot;; pinctrl-0 = &amp;lt;&amp;amp;spi0_pins &amp;amp;spi0_cs_pins&amp;gt;; cs-gpios = &amp;lt;&amp;amp;gpio 8 1&amp;gt;, &amp;lt;&amp;amp;gpio 7 1&amp;gt;; spidev0: spidev@0{ compatible = &quot;spidev&quot;; reg = &amp;lt;0&amp;gt;; /* CE0 */ #address-cells = &amp;lt;1&amp;gt;; #size-cells = &amp;lt;0&amp;gt;; spi-max-frequency = &amp;lt;125000000&amp;gt;; }; spidev1: spidev@1{ compatible = &quot;spidev&quot;; reg = &amp;lt;1&amp;gt;; /* CE1 */ #address-cells = &amp;lt;1&amp;gt;; #size-cells = &amp;lt;0&amp;gt;; spi-max-frequency = &amp;lt;125000000&amp;gt;; }; 5110lcd@3{ compatible = &quot;adafruit,Nokia5110 LCD&quot;; reg = &amp;lt;3&amp;gt;; spi-max-frequency = &amp;lt;32000000&amp;gt;; dc-gpios = &amp;lt;&amp;amp;gpio 9 GPIO_ACTIVE_HIGH&amp;gt;; reset-gpios = &amp;lt;&amp;amp;gpio 11 GPIO_ACTIVE_HIGH&amp;gt;; backlight = &amp;lt;&amp;amp;bgpio 7 GPIO_ACTIVE_HIGH&amp;gt;; };};Propriétéscompatible &amp;lt;manifacture, modele&amp;gt; : avec cette propriété , l’OS va décider quel driver va se lier à ce composant.Reg : Cette propriété dépend du type de bus sur lequel on est raccordé, elle est composé comme suite &amp;lt;adresse , length&amp;gt;,cela veut dire que la zone réservée pour le node lcd commence à partir de adresse et sa taille est length. Chaque adressse est une liste de un ou plusieurs cellules (cells).La taille aussi peut etre une liste de cellules de 32 bits.Puisque les adresses sont de variables de taille length , dans le node parent on va specifier:#address-cells : nombre de cellules 32 bits necessaires pour former l’adresse de reg#size-cells : nombre de cellules 32 bits necessaires pour former la taille de reg il y a deux façons d’ajouter la section dans le DT, soit en cherchant le .dts de la carte cité précédemment, soit en décompilant le dtb, je préfère cette dernière car on a plus d’informations sur la taille des zones mémoires et leurs offsets .Le contrôleur de gpio est spécifié avec 2 cellules #gpio-cells donc pour spécifier les gpio,on besoin d’un phandle sur le contrôleur de gpio, du numéro de la ligne gpio (celle 1) et d’un flagactive low/high (cell 2).Il faut regarder le dts décompilé pour voir comment est définit le contrôleur gpio.Data/Control gpio : comme dit dans la partie 1 est une entrée pour choisir le type de donnée selonce qu’on lui envoi : 0 ou GPIO_ACTIVE_HIGH pour DATA 1 ou GPIO_ACTIVE_LOW pour ControleLe controleur gpio déclare des pins soit en mode GPIO soit en mode ALT, ce qui veut dire alternate function, cela veut dire qu’elle sont utilisé dans un autre mode que le gpio simpleexemple : chip-select du SPI, Clock pour i2c,PWM …etcchaque pin peut avoir plusieurs alternate functionsPour choisir tel ou tel fonction, il faut changer les 3 bits du registre AF .En résumé:J’ai choisis dans le device tree un GPIO pour le backlight, un GPIO de RESET et un autre de controle. les autres je fais apelle à eux depuis le driver.Fonction de probe ()Fonction de probe()La fonction de probe est appelée au démarrage du kernel, ou quand on plug le device (dans le casd’un device déconnectable). On dit qu’elle est appelée à chaque fois que device est vu (À compléter plus tard ).Son rôle en gros est de détecter le device (dans notre cas le LCD). Cette fonction fait l’initialisation du device, l’initialisation du hardware, enregistrer le framework kernel nécessaire ..etcGreg-Kroah Hartman disait “les drivers sont simples à écrire, ce qui est difficle est de comprendre le materiel”Alors !! C’est simple, le chantier est difficle, je dois convetir un driver deja existant qui est un Driverframbuffer en driver DRM. yen a plusieurs mais j’ai choisis détudier le fb_hx8357d.c et son equivalent DRM hx8357d.c" }, { "title": "K&amp;R Quelques Notes", "url": "/posts/KR/", "categories": "Linux, C", "tags": "c k&r", "date": "2022-06-12 00:09:00 +0200", "snippet": "Quelques notes tiré du livre de Kernighan et Ritchie.Limites des typesDes nombres très spéciaux permetent d’atteindre les limites des types float et double: float : &amp;gt;= 111e28 double :&amp;gt;= 1111e297Sans ces nombres, incrémenter FLT__MAX donnera toujours FLT__MAX et jamais inf.On gros pour atteindre inf, il faut un nombre sufisament grand ! Pour quoi ? je ne sais pas.Initialisation des variables Les variables locales doivent toujours étres initialisés Les variables extern et static sont mises à 0 par defautunsigned seulepeut on déclarer une variable avec juste unsigned ?Oui, c’est déclaré comme un usigned int" }, { "title": "CheatSheet vim", "url": "/posts/cheatsheet-vim/", "categories": "CheatSheet, Vim", "tags": "", "date": "2022-06-06 19:36:00 +0200", "snippet": "Remplacer des mots:/s/mot/Remplaçant/ : premiere occurence de mot:/s/mot/Remplaçant/g : toutes occurence de mot dans la ligne courante :%s/mot/Remplaçant/g : toutes les occurence de mot dans tout le fichier:3,10s/mot/Remplaçant/g : toutes les occurence de mot entre les lignes 3 et 10 incluses" }, { "title": "Cheatsheet git", "url": "/posts/cheatcheet-git/", "categories": "CheatSheet, Git", "tags": "", "date": "2022-06-02 10:13:00 +0200", "snippet": "Nouveau repogit initgit add filesgit commit files git remote add origin &quot;github-repository-url&quot;# show origin git remote -v # change URL git remote set-url origin &quot;new url&quot;# push git push -u origin master " }, { "title": "Cheatsheet Love2D", "url": "/posts/cheatsheet-love2d/", "categories": "CheatSheet, Love2D", "tags": "", "date": "2022-05-28 21:50:00 +0200", "snippet": "Love2D introductionfunction creatReact(ax,ay) -- Creer un rectangle, -- La fonction doit avoir des paramétres rect ={} rect.x = ax rect.y = ay rect.width = 100 rect.height = 50 rect.speed = 100 -- Controle de vitesse de déffilementtable.insert(list0Rectangls,rect)end function love.load() -- Fonction exécutée une seule fois list0Rectangls = {}creatReact(10,150)creatReact(220,150)endfunction love.update(dt) -- Fonction exécutée en alternance avec love.draw() for i,v in ipairs(list0Rectangls) do v.x = v.x + v.speed * dt -- Vitesse de déffilement controlé ici -- dt : est un delta time, dt=1/fps du Pc -- en 1s, mon Pc(100fps) se met à jour 100 fois en 1 seconde, chaque fois, il augmente x de v.speed*dt -- explication: -- 1/100 veut dire que chaque image prend 0.01 s -- avant, je deplace le rectangle sur l&#39;ax X de 5 chaque 0.01s , ce qui est rapide (5pixel/0.01s) -- avec dt, je déplace le rectangle sur X de 0.05 chaque 0.01 s , ce qui lent (5pixel/1s) -- Pour augmenter la vitesse =&amp;gt; augmenter v.speed end end --function love.keypressed(key)-- if key == &quot;space&quot; then -- creatReact()-- end--end function love.draw() for i,v in ipairs(list0Rectangls) do -- Parcour toutes la table et leurs sous-tables et pour chaque sous-table -- dessiner un rectangle et le déplacer grace à update love.graphics.rectangle(&quot;fill&quot;, v.x, v.y, v.width, v.height) end --love.timer.sleep(1)end Fichier multiples et porté des variables" }, { "title": "CheatSheet LUA", "url": "/posts/cheatsheet-lua/", "categories": "SheeCheat, Lua", "tags": "", "date": "2022-05-22 16:02:00 +0200", "snippet": "Variablesa = 5b = 9a,b = 0,1print(a+b)Typage dynamiqueLa variable connait son type en fonction de la valeur ou de l’objet qui lui ai assigné.a = 1a = {nom = &quot;monkey&quot;}On peut obtenir le type d’une variable grace à type()print(a,type(a))Concatenationage = 25nom = &quot;monkey&quot;print(&quot; Je suis &quot;..nom..&quot;j&#39;ai \\t&quot;..age..&quot;ans&quot;)Casse SensibleIncrémentationage = age + 1Fonctionsfunction foo(nom) prenom = &quot;linux&quot; print(&quot;hello &quot;..nom) return nom..&quot; &quot;..prenom end -- autre methode : assigner function() à une variable.x = function() print(&quot;hello) endprint(x())On peut renvoyer plusieurs variables dans une fonction.function foo(a,b) return math.pow(a,b),math.pow(c*b,a)endprint(foo(2,7))On peut renvoyer dans une table tab = {foo(2,3)} et utiliser pairs() pour la lire.Dans une fonction qui renvoit plusieurs valeurs, on peut extraire que la première valeurvar = (foo(2,1))Ici var n’est pas une table.ou bien le premier élement de la tabletab = ({foo(2,3)})[1]Ici var n’est pas une table.Booléennot true == false(true ~= false) retourne truenil Veut dire la variable n’a aucune valeur asignée.tablestab = {} print(x) Affiche l’adresse mémoire de la table.tab = {nom = &quot;monkey&quot;, age = &quot;25&quot;} print(tab.nom) print(tab.age) print(tab[1]) --Faux car tab est un dictionnaire table 2D tab = { data={age=&quot;25&quot;,emplois=&quot;ingenieur&quot;}, data2={passion=&quot;retogaming&quot;,fruit=&quot;melon&quot;} }print(tab.data.age)print(tab.data2.fruit) dictionnaire En lua tout est une question de tabletab = {} -- cree une table vide tab[1]=1,tab[2]=2 -- cette ligne ==tab = {1, 2} -- à cette ligne tab = {[1]=1,[2]=2} -- == à cete lignetab = {} -- ces deux ligne sont les équivalentestab.fruit=&quot;orange&quot;tab[&quot;fruit&quot;]=&quot;orange&quot;tab = {} -- ces deux ligne sont les équivalentestab[&quot;fruit&quot;]={} -- creer une table fruit dans tabtab[&quot;fruit&quot;].couleur=&quot;orange&quot; -- creer un doctionnaire dans la table fruit-- on peut refaire tout ça en une ligne tab.fruit.couleur =&quot;orange&quot;print(#tab) -- Donne la taille de la table Si c’est un dictionnaire, #tab revoit 0Instructions de selection While ..do ..end i = 0while i &amp;lt; 10 do print(&quot;hello \\t&quot;..i) i = i + 1enduse break to break repeat .. until i = 0 repeat print(&quot;Hello World!&quot;) i = i+1 until i ==10use break to break for .i, limit, step.. do .. end -- Numeric iterationfor i = 0,10 do print(&quot;hello&quot;)end -- sequential iterationtab = {1,2, fruit = &quot;banane&quot;, &quot;monkey&quot;, 8} for key,value in pairs(tab) do print(key,value) end --keys : sont les index --value : sont les valeurs --fruit = &quot;banane&quot; est un dictionnaire donc donc index est toujours le dernier --donc c&#39;est le dernier à être affiché next() print(next(tab,&quot;pi&quot;)) afficher la prochaie paire (key,value) pairs() permet d’itérer sur une paire (key,value)ipair() permet d’itérer que sur une paire (index,value)ce qui veut dire qu’il affiche pas les dictionnaires {nom=&quot;monkey&quot;} Itération avec next() for key,value in next,tab,nil do print(key,value)end--applique next() à tab en commençant par nil(car next nil c&#39;est index 1) --la boucle for est exécuté jusqu&#39;à ce que next() renvoit nil, nil signifie extrémité de la table if .. then ..else .. end if.. then ..else ..endif ..then ..elseif..then..else ..endPortée des variables Pour appeler une variable d’un autres fichier : require(&quot;nomFichier&quot;) Un fichier peut retrouner une valeur en LUA si on met à sa fin return nomVariable On peut créer une variable local à un bloc :if true then local var = 30 -- existe que dans ce bloc end une variable global est prioritaire dans le cas d’un require:var = 30require (&quot;nomFichier&quot;) -- Il y a une variable var = 30 à l&#39;intérieurprint(var) -- Affiche 30" }, { "title": "Notes", "url": "/posts/notes/", "categories": "Temps et Calendrier", "tags": "", "date": "2022-05-17 09:22:00 +0200", "snippet": "projet en cours … driver drm nokia 5110 LCD : en retardProchain article livre de sigmund sur linux : partie toolchain J’ai découvert des erreurs d’identation dans les premiers articles, beacoup d’erreurs d’indentation. Il faut absolument relire avant de de déployer sur la frequence du NES processors, j’ai oublié MHZ avant de faire le prochain article, verifier l’orhtographe et la ponctuation de tout les articles si non les articles vont s’accumuler et ils seront difficle à corrigerSujet à traiter parler du stage et présenter mes drivers démarer le driver du nokia lcd : en cours .. corriger les exercices du langage c : en cours .. faire une rubrique speciale pour FAQ langage c suivre la communauté open source et parler un peux des évenements chaine de cross compilation, mettre les codes et essayer un petit programme sur qca- tuto reseaux comme creer un vlan prise de notes sur dfs cac ..etc, cela evite de tout relir. routage et vlan et gre tunels des notes commandes uci .. Le livre sur les algorithmes en C.Notes importantes Il faut accoder du temps pour les reseaux, regader les nat les bridg et les IP et les routes Ilfaut supprimer le fait que je travaille actuellement pour voir si mon profile intéresse des gens. Quand tu va faire le driver du lcd, il faut commencer par expliquer le makefile de la cross compilation avec les kernel headers Typographie et OrthographePour écrire des articles, il vaut mieux utiliser des ponctuationlire l’article sur ça que j’ai sauvegardéDes idéesune busybox linux qui s’apelle macgiver qui regroupe des commandes importante ou une commande et qui regroupe d’autresune idée d’un jeux, développer une boule qui voyage à travers le monde cette boule peut s’acheter ou se connecter librement d’un utilisateur de l’application à l’autre elle va parcourire la distance et afficher en temps réel le déplacement en anonymeune boule ou un personnage" }, { "title": "Cheatsheet bash", "url": "/posts/cheatsheet-bash/", "categories": "CheatSheet, Bash", "tags": "", "date": "2022-05-16 22:17:00 +0200", "snippet": "1. tailCette commande affiche les 10 derniere ligne d’un fichier -n5 : les 5 dernieres lignes n+5: à partir de la ligne 5 -c5 : les 5 derniers octets -f voir ce qui a été ajouté aux fichiersls -l | tail -n5Chercher les 5 derniers fichiers ou dossiers modifiés2. aliasCréer un alias pour une commande Temporaires alias nom_alias=&#39;commande&#39; Permanents alias nom_alias=&#39;commande&#39; dans bashrcalias liste les aliasunalias nom_alias pour supprimer3. variables spéciales $# : nombre d’arguments passés à this-&amp;gt;script $* :affiche tout les arguments passés au script $1 :les arguments 1 et 2 $0 :le nom du script $ _ :la derniere commande passée au shell $? :la commande passée s’est elle bien déroulé 0 if true 1/2 else $$ :numero du processus actuelChercher un patern dans des fichiersack &quot;patern&quot;grep -rnw &#39;/path/to/file&#39; -e &#39;patern&#39; -r : recursive -n : line number -w : match all wordEnvoyer binaire par TFTP(echo binary; echo put file.bin ) | tftp ip_addRedirection2&amp;gt;&amp;amp;1 : stderr to stdout&amp;amp;&amp;gt;/dev/null all to null " }, { "title": "Interface WIFI en Mode Moniteur", "url": "/posts/wireshark-monitor-wifi/", "categories": "Réseaux", "tags": "wifi", "date": "2022-05-03 19:13:00 +0200", "snippet": "J’ai fait une petite modification dans la partie wireless de Linux, plus exactement dans l’interface nl80211 qui est une interface de communication entre les programmes du userspace (wpa_supplicant, iw, etc) et des modules et drivers du kernel cfg80211 et mac80211.Wireless Linux SubsystemMa modification portait sur le fait d’autoriser une STA (client) à faire un scan actif, c’est à dire envoyer des probe request pour découvrir des AP.Pour voir ces probe request, on doit configurer une carte radio (celle de mon pc) en mode moniteur. Avec le moniteur, on peut écouter tout le trafic sur le canal courant, on verra des probe request/response, des beacon frames mais aussi des paquets dedonnées et de contrôle.On peut faire un moniteur de plusieurs façon, la première on configurant notre interface wifi en mode moniteur:sudo su ip link set wlp2s0 downiw wlp2s0 set monitor noneip link set wlp2s0 up le deuxieme en creant une autre interface wifi virtuelle en mode moniteurpour créer une autre interface de type moniteur :iw dev wlp2s0 interface add monit0 type monitor ip link set monit0 up voila ce que donne la commande iw dev infointerface wlp2s0 ifindex 3 wdev 0x1 addr a4:4e:31:cf:dd:a4 ssid Bbox-D26E0858 type managed channel 48 (5240 MHz), width: 40 MHz, center1: 5230 MHz txpower 15.00 dBmJ’ai une interface type managed, veut dire mode STA(client) La création d’une autre interface wifi type moniteur doit être supporté par le driverCertains drivers ne supportent pas deux ifaces fonctionnant en tandem.Petit coup d’oeil sur wiresharkLes beacons sont envoyés par les AP chaque 102ms , ils contiennent des informations sur la BSS.Un AP envoi un beacon contenant des informations sur lui notamment son BSSID. Les services qu’il peut fournir, etc.Il y a 3 types de trames dans 802.11 : Management frames Data frames Control framesUn client pour découvrir des AP envoi des probe requests(management frames) ces derniers peuvent être ciblés vers des AP ou broadcasté. L’AP qui les a reçu répond par des probe respons.Pour voir ces beacons, il faut faire un peux de filtrage, voici les filtres qu’il faut appliquer selons la trame qu’il faut mettre en évidence (0x type sybstype)https://www.wifi-professionals.com/2019/03/wireshark-display-filtersversion pdfPour voir les trammes de management, il faut appliquer ce filtre wlan.fc.type == 0Management framesOn voit ma box qui broadcast son SSID. Mon téléphone qui envoie et reçoit des trames d’authentification puis envoi desAssociation Request et reçoit Association Respons de ma box." }, { "title": "Script shell vicieux", "url": "/posts/script-shell-vicieux/", "categories": "Linux, Shell", "tags": "shell snmpget", "date": "2022-04-05 23:07:00 +0200", "snippet": "J’ai écrit un petit script bash pour interroger des clients pour savoir si un daemon (collectd) est activé sur eux.#!/bin/baship=&quot;10 11 12 20 30 32 34 35 36 37 38 39&quot;ip=&quot;$ip 40 41 42 43 44 45 46 47 48 49&quot;ip=&quot;$ip 50 51 52 53 54 55 56 57 58 59&quot;for i in $ip; do RESULT=$(snmpget -v2c -d -D ALL -c public 192.168.2.$i .1.3.6.1.4.1.28097.10.9.1.0 | tail -1) sleep 1 if [ &quot;$RESULT&quot; == &quot;iso.3.6.1.4.1.28097.10.9.1.0 = INTEGER: 2&quot; ]; then echo COLLECTD ACTIVATED IN $i else echo NOT ACTIVATED IN $i fidoneexitComme vous le voyez c’est assez simple, j’ai une liste d’adresses IP que je parcoure dans une boucle for. Dans la boucle for, je fais un snmpget avec l’OID du daemon qui spécifie si dernier est activé ou désactivé, à fin,j’extraie la dernière ligne qui contient le retour de snmpgetet je fais des conditions.Commades utilisées tail -1 : extrait la derniere ligne d’un fichier snmpget : lire la MIB sur le produit et renvoyer l’information qui correspondent à l’OID. -v2c : utiliser la version 2 de snmp -d : dump les packets I/O en hexadecimal -D ALL : mode debug extrem verbosity -c public : community string, c’est un peux comme un ID ou un password pour permettre l’accés au informations du client. adresse ip &amp;amp; OID Mais alors ou est le soucis ?Le soucis est que ce programme rentre dans la condition if [...] que dans la dernière itération de la boucle ! c’est à dire ip=59 La cause de ça est que snmpget pollue les sortie stderr avec des messages et provoque ça, en redirigeant la sortie stderr vers stdout ou vers un fichier, ça résout le soucis. RESULT=$(snmpget -v2c -d -D ALL -c public 192.168.2.$i .1.3.6.1.4.1.28097.10.9.1.0 2&amp;gt;&amp;amp;1 | tail -1) 2 : descripteur de fichier pour stderr 1 : descripteur de fichier pour stdout ’&amp;gt;’ oprateur de redirection. &amp;amp; spécifie qu’on redirige la sortie vers un descripteur de fichier.Voila voila, c&#39;etait chiant ! Redirection shell2&amp;gt;&amp;amp;1 : sterr to stdout &amp;amp;&amp;gt; /Dev/NULL: les deux" }, { "title": "Driver Linux pour Nokia 5110 LCD (PARTIE 1)", "url": "/posts/driver-nokia5010lcd-part1/", "categories": "Linux, Drivers", "tags": "drivers linux, lcd driver, nokia5010", "date": "2022-04-02 19:47:00 +0200", "snippet": "Précédent , j’avais parlé d’un projet de drivers Linux, on y ait arrivé !Le premier driver est donc pour l’afficheur LCD du Nokia 5010, vous connaissez tous le Nokia 3310 ! le 5110 est son grand père.Le matérielModule LCD Nokia 5110Quelques spécifications : Technologie  : LCD monochrome Résolution  : 84x48 pixels Taille  : 43,6 mm x 43,1mm Bus  : Interface Série Contrôleur : PCD8544 Alimentation  : 2.7V-3.3VCet écran est très utilisé par les bidouilleurs, notamment avec des microcontrôleurs : ATMEL, PIC, STM32 …il présente la particularité d’être munie d’un contrôleur PCD8544 qui contrôle les opérations d’affichage. Voici sa datasheet, elle nous sera très utile . Mon LCD 5110 est un clone chinois, je ne sais pas si toutes les caractéristiques correspondent à cette datasheet.La cible est un Raspberry PI 4, le driver sera cross-compilé sur une architecture ARM 64-bit.Raspberry Pi 4 Model BJ’ai décidé de compiler tout le driver pour OpenWrt. Au début je voulais le faire pour Automotive Grade Linux car je suis très intéressé par l’embarqué automobile, mais l’OS est difficile à compiler, il y a beaucoup de dépendances et je ne connais pas Yocto ce qui n’arrange rien.Ceci dit, je reviendrais sur AGL après.Openwrt est simple car il est construit avec buildroot, c’est un Linux qu’on trouve beaucoup sur des routeurs donc assez léger. En plus la version du Kernel est récente.CablageCablage sur RPi4pinsC’est important de comprendre les pins car c’est avec ça qu’on va écrire le device tree reset : Reset le module quand 0v est envoyé (active low) CE : Pin de selection en cas ou plusieurs slaves sont branchés au SPI (active low) DC : Les informations envoyées sont soit des données (D/high) soit des suites controle (C/low) DIN : MOSI CLK : Une horloge pour le SPI VCC : Alimentation 2.7v à 3.3 v BL : Backlight GND : GoundC’est tout pour aujourd’hui, on commence à développer dans la seconde partie." }, { "title": "Fuites mémoire, les dangers des tableaux en C", "url": "/posts/bug-wacd-surconsommation/", "categories": "Bugs, Openwrt", "tags": "fuites mémoire, Openwrt", "date": "2022-03-06 14:59:00 +0100", "snippet": "Petit bug intéressant !Je travaillais sur un daemon custom écrit en C qui s’appelle WACD. Ce daemon produisait une surconsommation de la RAM telle ! que le système IPC (ubus) dont il est inclut crachait.La cause de cette surconsommation est… un simple unint8_t regardez bien ce petit code :extern ap_info_t *ap_track_add(prob_announce_t prob){ struct ap_info *ap; local_ap_info_t *local_ap; //uint8_t hash_index = prob.ap_macaddr[5]; int i; uint8_t ap_index = -1;/* ap = ap_track_get(prob.ap_macaddr, prob.ssid); if (ap) { */ /* Move the most recent entry to the end of the list */ /* list_del_init(&amp;amp;ap-&amp;gt;list); list_add_tail(&amp;amp;ap-&amp;gt;list, &amp;amp;ap_seen[hash_index]); time(&amp;amp;ap-&amp;gt;last_seen); ap-&amp;gt;num_sta_associated = prob.num_sta_associated; ap-&amp;gt;band_capabilities = prob.band_capabilities; memcpy(ap-&amp;gt;ssid, prob.ssid, SSID_MAX_LEN); ap-&amp;gt;max_sta_num = prob.max_sta_num; return ap; } */ Add a new entry // Get last ap_index for (i = 0; i &amp;lt; MAX_LOCAL_AP; i++) { if(ap_list[i] == NULL) { ap_index = i; break; } } if(ap_index == -1) { dbg_print(LOG_ERR, &quot;AP list is full.\\n&quot;); return NULL; } local_ap = malloc(sizeof(local_ap_info_t)); if (!local_ap) { dbg_print(LOG_ERR, &quot;Cannot allocate memory for local_ap.\\n&quot;); return NULL; } local_ap-&amp;gt;gctx = NULL; memset(&amp;amp;local_ap-&amp;gt;ap, 0, sizeof(ap_info_t)); ap = &amp;amp;local_ap-&amp;gt;ap; memcpy(ap-&amp;gt;macaddr, prob.ap_macaddr, ETH_ALEN); memcpy(ap-&amp;gt;ssid, prob.ssid, SSID_MAX_LEN); ap-&amp;gt;band_capabilities = prob.band_capabilities; ap-&amp;gt;max_sta_num = prob.max_sta_num; time(&amp;amp;ap-&amp;gt;last_seen); ap_list[ap_index] = local_ap; INIT_LIST_HEAD(&amp;amp;ap-&amp;gt;list);[8]On déclare une variable locale ap_index de type uint8_t. Ce type -dans la norme ISO C99: 7.18 Integer types- de la librairie &amp;lt;stdint.h&amp;gt; est défini comme suite :/* Unsigned. */typedef unsigned char uint8_t;/* Maximum of unsigned integral types. */# define UINT8_MAX (255)On assigne à cette variable -1, un entier négatif, cela n’est pas une erreur en soit car la valeur va être convertie en unsigned comme ceci : UINT8_MAX + 1 -1 = 255 . (C standard [C99 6.3.1.3])On aura ap_index == 255[27]ap_index reçoit une valeur i allant soit de 0 à MAX_LOCAL_AP ou reste à 255 si le test [26] est faux.Ps : MAX_LOCAL_AP == 8[31]On teste if (ap_index == -1), on sort de la fonction si c’est vrais. C’est la où il y a une erreur !À la sortie de la boucle for, la valeur de ap_index est toujours testée. Le but est de sortir de la fonction complète dans le cas ou la condition 26 de la boucle for est fausse (liste pleine), à ce moment la ap_index n’a pas changé depuis sa définition et donc on doit sortir de la boucle. Le soucis est que ap_index ne vaudra jamais -1 car sa valeur est convertie en 255.[35]Le test étant faux, on alloue de la mémoire pour une structure local_ap_info_t qui est très grande. C’est ça qui provoque la surconsommation de la mémoire.[48]On fourni à ap_list à l’index 255 l’adresse de la mémoire alloué précédemment.Cette dernière étape est intéressante. ap_list est un tableau de pointeurs dont la taille est fixée à MAX_LOCAL_AP càd 8.En C/C++, pour des buts de vitesse, il n’y a pas de bounds checking en utilisant les tableaux. On peut accéder à un index 255 d’un tableau de 8 cases.Le comportement dans ce cas est indéfini. C’est une bonne méthode d’attaque par Buffer Overflow.ExplicationDans le cas où le tableau est local à une fonction, la mémoire lui est réservée dans le stack (pile).Dans ce cas, déborder du tableau c’est juste accéder à une autre zone allouée dans la pile. Il n’y aura pas de segmentation fault que lorsqu’on déborde de la pile en entier.Voilà tout, si vous avez des remarques, n’hésitez pas en m’en faire part !À une prochaine." }, { "title": "Mon premier ordinateur", "url": "/posts/mon-premier-pc/", "categories": "Retro-informatique, Consoles", "tags": "famiclone", "date": "2022-02-25 23:50:00 +0100", "snippet": "J’ai reçu quand j’étais jeune une console de ce genre.Mon premier ordinateur 8 bitsC’est un clone de la Nintendo Famicom comme il y en a des centaines.Durant la fin des années 80 et début des année 90, la Nintendo NES (Famicom au Japon) avait atteint son apogée, elle est devenue en 1990 la console la plus populaire de l’histoire du jeux vidéos. Ce succès avait induit l’émergence de fausses NES portant plus tard le nom de Nintendo Famiclone.C’est généralement dans les pays où la NES n’a pas été déployée que ces clones sont commercialisés et/ou fabriqués, comme l’ex URSS, Le Moyen-Orient, l’Amérique du Sud où les clones de NES avaient la même popularité que la console originale au Japon ou en Europe.Les clones les plus populaires sont fabriqués par Micro Genuis, une société taïwanaise. Un des plus célèbres de ces clones est le Dendy de Steepler Ltd fabriqué en Chine et à Taïwane en 1992. Déployé essentiellement en Russie ! le Dendy se décline sous différentes versions et styles, parfois on trouvait des Dendy sous forme SEGA Mega Drive.Clone NES Dendy sous forme de Mega DriveIl y a dans la majorité du temps une compatibilité entre les jeux licenciés Nintendo et ces clones, ce qui fait d’eux des consoles versatiles car dépourvues de zonage. Ils peuvent faire fonctionner des jeux hackés, fait-maison, sans licence Nintendo et des cartes all in one commela célébre 9999 Games to 1.Cartouche d’un Famiclone 99999…etc in 1Durant le Krash du jeux vidéo en 1983, les consoles de jeux se vendaient beaucoup moins, le public préférait se tourner vers des ordinateurs familiaux comme le Commodore 64, le TRS80, le Sinclair Zx80/spectrum et j’en passe. C’est dans ce contexte que Nintendo avait ajouté des accessoires à sa console :Un enregistreur de cassettes, des joysticks, des manettes et enfin un clavier avec une cartouche de Basic (Fammily Basic),un langage de programmation très en vogue à l’époque des ordinateurs 8 bits.C’est ainsi que des clones de NES sont apparues sous forme de claviers intégrants une interface graphique interactive, différents logiciels d’éducation (mathématique, musique, dessin, etc) et bien sûr le G-Basic. Beaucoup de développeurs ont écrit leurs premières lignes de code sur ces clones, c’était mon cas mais je ne savais pas ce que j’écrivais : je ne savais pas ce que c’était à vrais dire !Interface Graphique d’un Famiclone Educationnal ComputerSpécification techniqueLe processeur principale de la Famicom est un Ricoh 20A3 8 bits basé sur le noyau d’un MOS 6502 cadencé à 1,789 772 5  (NTSC) ou 1,773 447  (PAL).C’est un processeur compatible 6527P qui a servit pour le Dendy. La plupart des famiclone récents sont basés sur un NES-on-a-chip ASIC ou Nintendo On a chip (NOAC). Des constructeurs de clones ont ajoutés des système de rétrocompatibilité qui permettent aux développeurs de rajouter des équipements pour un meilleur rendu graphique et sonore, e.g. un processeur plus performant comme le 65C816 de la Super NES qui est une version amélioré du 65C02.Voilà une brève histoire de ces Famiclone, je leurs doit beaucoup personnelement. Si vous en croisez un notamment sous forme de clavier , n’hésitez pas à me contacter !à la prochaine." }, { "title": "Projet de Drivers Linux", "url": "/posts/projet-drivers-linux/", "categories": "Linux, Drivers", "tags": "projet drivers linux", "date": "2022-02-17 22:27:00 +0100", "snippet": "Quand j’ai commencé à m’intéresser aux drivers Linux, on m’avait orienté vers le livre que j’ai présentéici, Linux Device Drivers de Jonathan Corbet, Alessandro Rubini et Greg Kroah-Hartman.Ce livre est une référence dans le domaine. Les auteurs -dont l’actuel mainteneur de la branche stable Greg Kroah-Hartman- ont essayé de rester le plusindépendant possible du hardware, la seule chose dont on avait besoin pour utiliser ce livre et développer ses codes est un ordinateur. Pour y arriver, ils ont développé tout les drivers sur la RAM, c’est à dire simuler le device sur une plage de mémoire vivede l’ordinateur. C’est une excellente méthode car elle ne demandait pas au lecteur de se munir de tel ou tel périphérique pour pouvoir apprendre.Néanmoins, quand j’ai fait mon stage chez Tiempo Secure et que j’ai eu comme tache de développer un driver pour un composant (cliquez ici) ; je me suis confronté à un grand soucis. J’avais appris avec le livre les bases et les méthodes nécessaires, mais je n’arrivais pas à voir legap qu’il y avait entre un driver sur la RAM et le driver d’un vrais device. En Gros, j’avais une idée du fonctionnement des drivers Linux,mais je ne savais pas par où commencer à développer le mien.Ce gap (écart) était pour moi le type de mon driver, je n’arrivais pas choisir un type de driver à mon device et l’API kernel à utiliser : j’étais perdu !Suite à ça, j’ai eu comme idée décrire des drivers pour quelques devices. Le but est d’utiliser les enseignements du livre et ma petite expérience afin d’expliquer la façon d’appréhender le driver d’un réel device pour la première fois. Donc ici,je vais être très dépendant du hardware. J’expliquerai toutes les étapes les plus importantes et donner une vue synthétique et complète de chaque driver, et surtout ! éviter aux autres de tomber dans les mêmes pièges que moi.J’ai acheté des capteurs sur Ali Axpress, je vais en sélectionner 10 qui vont englober au maximum le contenu du livre et différentes librairies et API kernel à utiliser. Sur chaque chapitre du livre, je vais essayer de mettre en pratique les connaissances acquises afin de mieux comprendre le sujet. Voila pour l’essentiel. J’ai déjà en tête le premier driver à faire et le device à utiliser. Rendez vous au prochain épisode !" }, { "title": "Mes références Linux embarqué", "url": "/posts/mes-livres-linux/", "categories": "Références, Livres", "tags": "livres linux embarqué", "date": "2022-02-10 22:56:00 +0100", "snippet": "Voici quelques livres que je possède. Certains sont des achats ciblés, d’autres qu’on ma donné ou acheté aux puces.La majorité de ces livres sont disponibles en version Pdf gratuite. Moi je préfére les versions papier.À tout seigneur, tout honneur ♔Le langage C Norme ANSI 2e éditionThe C Programming languagei K&amp;amp;RJ’ai acheté ce livre 5 Euros sur le bon coin. Pas la peine de parler de lui, les auteurs en disent long.Le langage C est la porte d’entrée pour être un développeur Kernel et ce livre est un modèle de documentation technique.&quot;You can learn the C language without getting Kernighan and Ritchie, but that&#39;s doing it the hard way. You&#39;re also working too hard if you make it the only book on C that you buy.&quot; Jerry PournelleLa seule remarque à faire c&#39;est que c&#39;est en francais, parfois la traductions n&#39;est pas précise. J’ai commencé à corriger les exercices du livre, le repo est sur mon Github.Linux Device Drivers 3rd ÉditionLinux Device DriversLa bible du développeur de drivers Linux. C’est l’équivalent en terme de drivers du livre de K&amp;amp;R sur le C. On doit lire aucun livre sur les drivers avant celui ci. L’avantage de ce livre est qu’il contient des chapitres qu’on peut lire séparément sans forcement passer sur les autres. Je l’ai utilisé durant mon stage pour développer des drivers.Mastering Embedded Linux Programming Seconde EditionMastering Embedded linux ProgrammingC’est un excellent livre très accessible car il part du début. De la Toolchain au Bootloader puis au Kernel. Il parle des systèmes de fichiers,des mémoires, de temps réel, etc. Ce livre englobe presque toutes les couches d’un Linux embarqué. Il surfe parfois sur les sujets mais c’est assez pour comprendre et pas assez pour se perdre. Je me suis servi aussi de ce livre durant mon stage, plus précisément dans la partie UBI pour les mémoires MTD.Building Embedded LINUX SYSTEMSBuilding Embedded LINUX SYSTEMSUn livre de Karim YAGHMOUR, je l’ai acheté récemment et j’ai tout juste commencé à le lire. Ce qui ma intéressé, c’est le fait qu’il utilise parmi ses targets une console Sega Dreamcast pour compiler un Linux dessus. Comment dire !… C’est un livre qui se concentre sur les concepts et les explications plutôt que le code. Selon moi, l’auteur voulait mettre en valeur la compréhension des mécanismes." }, { "title": "Historique personnel", "url": "/posts/historique-personnel/", "categories": "À propos de moi, Centres d'intérêts", "tags": "passion linux", "date": "2022-02-06 23:59:00 +0100", "snippet": "PrésentationJe m’appelle Larbi, je suis ingénieur Linux embarqué débutant dans le domaine. Je vis dans le Val-d’Oise en île de France depuis un peux plus de 4 mois.J’ai fait mes études à l’université de Grenoble où j’ai préparé un master professionnel en systèmes embarqués.Découverte de l’informatiqueQuand j’avais environs 6 ans - début des années 2000 - j’ai reçu une console de jeux très SPÉCIALE. Un clone de la Nintendo Famicomque je présente ici. C’était mon tout premier ordinateur, pour les retrogamers d’entre vous, j’ai joué à des jeux comme Double Dragon, Contra, Ninja Gaiden, Lupin Sansei et j’en passe. Ma passion du retrogaming vient de la.Cette console, comme dit dans l’article possède une interface très interactive et est munie d’un Basic. J’y ai déjà mis les mains mais malheureusement, je ne savais pas ce que c’était.J’ai ensuite peux de temps après acquis un ordinateur Pentium 4 sous Windows 98. Je passais mon temps sur Encarta et Encarta junior et j’ai découvert la 3D dans les jeux.J’ai joué à deux types de jeux : ceux du PC natifs et ceux de la PS1 grâce à un émulateur Bleem!(liste des jeux auxquels j’ai joué).De nature extrêmement curieuse, je passais mon temps à bidouiller sur mon Pc. Je suis passé sous Windows XP, fait un peux de modding en augmentant la RAM, un lecteur DVD, une souris laser…Quand j’ai eu le Bac, j’ai directement choisis de faire un tronc commun math-informatique pour ensuite m’orienter vers des études d’électronique.Pour quoi des études d’électronique ?Car j’aime le hardware, j’adore interagir avec les registres, les mémoires avec du code. Je suis très intéressé par le développementbas niveau : Drivers, Bootloaders, Baremetal, etc.Durant mes etudes, j’ai travaillé à mis-temps dans une boite de maintenance informatique. J’ai appris beaucoup de chosessur la maintenance.Linux, open source &amp;amp; free softwareJ’ai découvert Linux quand j’étais adolescent, ma première distribution était Ubuntu 11. Je ne faisais rien de spéciale avec appart utiliser quelques commandes et faire des calculs basiques en Python. J’ai abandonné Windows car je savais que cette fenêtre menait nul part.À l’université, j’ai découvert la philosophie de l’open source et du free software et c’est naturellement dans le domaine du Linux que j’ai décidé d’évoluer.Mes passionsJ’ai deux grandes passions:1. l’informatique et la retro-informatiqueJe fais les puces souvent et j’ai quelques ordinateurs rares. Je suis un retro gamer, je trouve un grand intérêt à jouer à d’anciens jeux, cela donne une idée de comment les développeurs pensaient à cette époque et surtout je suis fasciné par leur talent de développeurs ! : A COMPREHENSIVE SUPER MARIO BROS DISASSEMBLY2. L’automobileJ’adore le Japon et la culture japonaise, notamment une discipline sportive que j’aborderai sûrement : le drift.J’aime les voitures japonaises, surtout celles d’entre 1980 et 2000 qui sont championnes de cette discipline : S13, Sil80, AE86 etc.Je m’intéresse à électronique embarquée automobile, j’ai eu quelques valises de diagnostique : Delphi DS150, Renault Clip. J’ai fait une formation d’un mois sur ça.Dans ce blog, je vais essayer d’étudier et de mettre mes notes sur Automotive Grade Linux, c’est quelque chose que j’ai dans le viseur depuis longtemps." } ]
